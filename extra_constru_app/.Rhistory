# empty vector of all 256 patterns. Adjust in the future to any number of states
pattern.counts<-numeric(4^4)
s=1
subset<-cbind(seq.data[combinations[,s],][1,],
seq.data[combinations[,s],][2,],
seq.data[combinations[,s],][3,],
seq.data[combinations[,s],][4,])
# get patterns and their counts without ambiguities
# for now this does not create relative frequencies, only counts
subset.patterns<-do.call(paste, as.data.frame(subset))
counts<-match(subset.patterns,patterns.list)
pattern.counts[as.numeric(names(table(counts)))]<-table(counts)
# get positions where ambiguities occur and subset patterns
amb.positions<-which(is.na(counts))
amb.patterns<-subset.patterns[amb.positions]
# Use the patterns to get a subset from a list() loaded previously
ambiguities<-amb.table[amb.patterns]
# this loop counts patterns resulted from equal distribution of ambiguities
pattern.counts.amb.all<-list()
for(k in 1:length(ambiguities))
{
amb.pattern.counts<-numeric(256)
amb.subset.patterns<-do.call(paste, as.data.frame(t(ambiguities[[k]])))
amb.counts<-match(amb.subset.patterns,patterns.list)
amb.pattern.counts[as.numeric(names(table(amb.counts)))]<-table(amb.counts)
pattern.counts.amb.all[[k]]<-(amb.pattern.counts)/dim(ambiguities[[k]])[2]
}
pattern.counts.amb.all.sum<-Reduce(`+`, pattern.counts.amb.all)
pattern.counts.combined<-pattern.counts+pattern.counts.amb.all.sum
#pattern.frequencies<-pattern.counts.combined/dim(seq.data)[2]
# Compute SVD Score
flat_12_34<-matrix(pattern.counts.combined, nrow=16, byrow=T)
flat_13_24<-(array(aperm(array((flat_12_34),c(4,4,4,4)),c(4,2,3,1)),c(16,16)))
flat_14_23<-(array(aperm(array((flat_12_34),c(4,4,4,4)),c(3,2,4,1)),c(16,16)))
flat_12_34_s<-Matrix(flat_12_34, sparse=T)
flat_13_24_s<-Matrix(flat_13_24, sparse=T)
flat_14_23_s<-Matrix(flat_14_23, sparse=T)
sqrt(round(1-sum(sparsesvd(flat_12_34_s, rank=16)$d^2)/norm(flat_12_34, type = "F")^2, 10))
sqrt(round(1-sum(sparsesvd(flat_13_24_s, rank=16)$d^2)/norm(flat_13_24, type = "F")^2, 10))
sqrt(round(1-sum(sparsesvd(flat_14_23_s, rank=16)$d^2)/norm(flat_14_23, type = "F")^2
)
)
svd(flat_12_34)$d
sparsesvd(flat_12_34_s, rank=16)$d
sqrt(sum(svd(flat_12_34, nu=0, nv=0)$d[5:16]^2))
sqrt(sum(svd(flat_13_24, nu=0, nv=0)$d[5:16]^2))
sqrt(sum(svd(flat_14_23, nu=0, nv=0)$d[5:16]^2))
sqrt(sum(svd(flat_12_34, nu=0, nv=0)$d[5:16]^2))
seq.data<-ReadCharacters("10state-nooutgcell.nex")
cells<-rownames(seq.data)
for(i in 1:dim(seq.data)[1])
{
seq.data[i,]<-as.numeric(c('A'='1', 'C'='2', 'G'='3', 'T'='4',
'M'='5', 'R'='6', 'W'='7', 'S'='8',
'Y'='9', 'K'='10')[seq.data[i,]])
}
# read look-up table for ambiguities M, R, W, S, Y, K
# this is a list() object that encodes patterns on 4-species, e.g., YCCM
# all letters are coded by numbers as above
# each pattern then has and associated matrix of equally distributed ambiguities
# that is a location for a pattern YCCC will have a matrix with columns
# CCCC and TCCC
amb.table<-readRDS("ambiguities_list_four_taxa.RData")
combinations<-combn(length(cells), 4)
patterns<-permutations(4,4,c(1:4), repeats=T)
patterns.list<-do.call(paste, as.data.frame(patterns))
# empty vector of all 256 patterns. Adjust in the future to any number of states
pattern.counts<-numeric(4^4)
names(amb.table)[1:10]
amb.table[[6]]
s=1
combinations[,s]
# subset 4 sequences
subset<-cbind(seq.data[combinations[,s],][1,],
seq.data[combinations[,s],][2,],
seq.data[combinations[,s],][3,],
seq.data[combinations[,s],][4,])
subset.patterns<-do.call(paste, as.data.frame(subset))
counts<-match(subset.patterns,patterns.list)
pattern.counts[as.numeric(names(table(counts)))]<-table(counts)
pattern.counts
# get positions where ambiguities occur and subset patterns
amb.positions<-which(is.na(counts))
amb.patterns<-subset.patterns[amb.positions]
# Use the patterns to get a subset from a list() loaded previously
ambiguities<-amb.table[amb.patterns]
pattern.counts.amb.all<-list()
for(k in 1:length(ambiguities))
{
amb.pattern.counts<-numeric(256)
amb.subset.patterns<-do.call(paste, as.data.frame(t(ambiguities[[k]])))
amb.counts<-match(amb.subset.patterns,patterns.list)
amb.pattern.counts[as.numeric(names(table(amb.counts)))]<-table(amb.counts)
pattern.counts.amb.all[[k]]<-(amb.pattern.counts)/dim(ambiguities[[k]])[2]
}
pattern.counts.amb.all.sum<-Reduce(`+`, pattern.counts.amb.all)
pattern.counts.combined<-pattern.counts+pattern.counts.amb.all.sum
# Compute SVD Score
flat_12_34<-matrix(pattern.counts.combined, nrow=16, byrow=T)
flat_12_34
flat_12_34/500
sqrt(sum(svd(flat_12_34/500, nu=0, nv=0)$d[5:16]^2))
flat_13_24<-(array(aperm(array((flat_12_34),c(4,4,4,4)),c(4,2,3,1)),c(16,16)))
flat_14_23<-(array(aperm(array((flat_12_34),c(4,4,4,4)),c(3,2,4,1)),c(16,16)))
flat_12_34_s<-Matrix(flat_12_34, sparse=T)
flat_13_24_s<-Matrix(flat_13_24, sparse=T)
flat_14_23_s<-Matrix(flat_14_23, sparse=T)
sqrt(round(1-sum(sparsesvd(flat_12_34_s, rank=4)$d^2)/norm(flat_12_34, type = "F")^2, 10))
sqrt(round(1-sum(sparsesvd(flat_13_24_s, rank=4)$d^2)/norm(flat_13_24, type = "F")^2, 10))
sqrt(round(1-sum(sparsesvd(flat_14_23_s, rank=4)$d^2)/norm(flat_14_23, type = "F")^2, 10))
temp <- matrix(nrow=3, ncol=2)
temp[1,1] <-paste(cells[combinations[1,s]], ",",
cells[combinations[2,s]],"|",
cells[combinations[3,s]], ",",
cells[combinations[4,s]], sep="")
temp[1,2] = sqrt(round(1-sum(sparsesvd(flat_12_34_s, rank=4)$d^2)/norm(flat_12_34, type = "F")^2, 10))
temp[2,1] <-paste(cells[combinations[1,s]], ",",
cells[combinations[3,s]],"|",
cells[combinations[2,s]], ",",
cells[combinations[4,s]], sep="")
temp[2,2] = sqrt(round(1-sum(sparsesvd(flat_13_24_s, rank=4)$d^2)/norm(flat_13_24, type = "F")^2, 10))#sqrt(sum(svd(flat_13_24, nu=0, nv=0)$d[17:256]^2))
temp[3,1] <-paste(cells[combinations[1,s]], ",",
cells[combinations[4,s]],"|",
cells[combinations[2,s]], ",",
cells[combinations[3,s]], sep="")
temp[3,2] = sqrt(round(1-sum(sparsesvd(flat_14_23_s, r
], sep="")
temp <- matrix(nrow=3, ncol=2)
temp[1,1] <-paste(cells[combinations[1,s]], ",",
cells[combinations[2,s]],"|",
cells[combinations[3,s]], ",",
cells[combinations[4,s]], sep="")
temp[1,2] = sqrt(round(1-sum(sparsesvd(flat_12_34_s, rank=4)$d^2)/norm(flat_12_34, type = "F")^2, 10))
temp[2,1] <-paste(cells[combinations[1,s]], ",",
cells[combinations[3,s]],"|",
cells[combinations[2,s]], ",",
cells[combinations[4,s]], sep="")
temp[2,2] = sqrt(round(1-sum(sparsesvd(flat_13_24_s, rank=4)$d^2)/norm(flat_13_24, type = "F")^2, 10))
temp[3,1] <-paste(cells[combinations[1,s]], ",",
cells[combinations[4,s]],"|",
cells[combinations[2,s]], ",",
cells[combinations[3,s]], sep="")
temp[3,2] = sqrt(round(1-sum(sparsesvd(flat_14_23_s, rank=4)$d^2)/norm(flat_14_23, type = "F")^2, 10))
temp
table(temp[,2])[min(names(table(temp[,2])))]==1
source("~/Documents/seq_to_SVDQ/load_nexus_return_best_quartet_v3.R")
choose(100,4)-3647631
(100*273594)/choose(100,4)
tree.qfm<-read.tree("4_state_best_quartetes_test.tre")
tree.svdq<-read.tree("10state-nooutgcell-tumor000-slice-biopsy-0000-nexus-files.tre")
tree.16<-read.tree("16_state_best_quartetes_test.tre")
true.tree<-read.tree("tumor000-slice-biopsy-0000.nwk")
TreeDistance(true.tree, tree.16)
TreeDistance(true.tree, tree.qfm)
TreeDistance(true.tree, tree.svdq)
getwd
getwd()
400000/60
400000/60^2
400000/60^3
4000/60
x<-c(1,2,3)
min(x)
which(min(x))
which(x==min(x)
)
x<-c(10,2,3)
which(x==min(x))
which(x==min(x))==1
which(x==min(x))==2
which(x==min(x))==3
ambiguities[[2]]
ambiguities[[3]]
do.call(paste, as.data.frame(t(ambiguities[[2]])))
amb.counts<-match(do.call(paste, as.data.frame(t(ambiguities[[2]]))),patterns.list)
patterns<-permutations(4,4,c(1:4), repeats=T)
patterns.list<-do.call(paste, as.data.frame(patterns))
amb.counts<-match(do.call(paste, as.data.frame(t(ambiguities[[2]]))),patterns.list)
length(amb.counts)
amb.counts
table(amb.counts)
match(do.call(paste, as.data.frame(t(ambiguities[[1]]))),patterns.list)
match(do.call(paste, as.data.frame(t(ambiguities[[2]]))),patterns.list)
match(do.call(paste, as.data.frame(t(ambiguities[[3]]))),patterns.list)
match(do.call(paste, as.data.frame(t(ambiguities[[4]]))),patterns.list)
as.numeric(names(table(amb.counts)))
x<-c()
x
x<-c(1,2,3,4)
x
x<-numeric(256)
x
seq.data<-ReadCharacters("10state-nooutgcell.nex")
cells<-rownames(seq.data)
for(i in 1:dim(seq.data)[1])
{
seq.data[i,]<-as.numeric(c('A'='1', 'C'='2', 'G'='3', 'T'='4',
'M'='5', 'R'='6', 'W'='7', 'S'='8',
'Y'='9', 'K'='10')[seq.data[i,]])
}
# read look-up table for ambiguities M, R, W, S, Y, K
# this is a list() object that encodes patterns on 4-species, e.g., YCCM
# all letters are coded by numbers as above
# each pattern then has and associated matrix of equally distributed ambiguities
# that is a location for a pattern YCCC will have a matrix with columns
# CCCC and TCCC
amb.table<-readRDS("ambiguities_list_four_taxa.RData")
# create all combinations of 4 from all species
# this gives a matrix of 4 rows and all possible combinations in columns
combinations<-combn(length(cells), 4)
patterns<-permutations(4,4,c(1:4), repeats=T)
patterns.list<-do.call(paste, as.data.frame(patterns))
# empty vector of all 256 patterns. Adjust in the future to any number of states
pattern.counts<-numeric(4^4)
s
# subset 4 sequences
subset<-cbind(seq.data[combinations[,s],][1,],
seq.data[combinations[,s],][2,],
seq.data[combinations[,s],][3,],
seq.data[combinations[,s],][4,])
subset.patterns<-do.call(paste, as.data.frame(subset))
counts<-match(subset.patterns,patterns.list)
pattern.counts[as.numeric(names(table(counts)))]<-table(counts)
# get positions where ambiguities occur and subset patterns
#amb.positions<-which(is.na(counts))
amb.patterns<-subset.patterns[which(is.na(counts))]
# Use the patterns to get a subset from a list() loaded previously
ambiguities<-amb.table[which(is.na(counts))]
amb.pattern.counts.sum<-numeric(256)
for(k in 1:length(ambiguities))
{
amb.pattern.counts<-numeric(256)
amb.subset.patterns<-do.call(paste, as.data.frame(t(ambiguities[[k]])))
amb.counts<-match(amb.subset.patterns,patterns.list)
# amb.pattern.counts[as.numeric(names(table(amb.counts)))]<-table(amb.counts)
amb.pattern.counts[amb.counts]<-1/dim(ambiguities[[k]])[2]
amb.pattern.counts.sum<-amb.pattern.counts.sum + amb.pattern.counts
#pattern.counts.amb.all[[k]]<-amb.pattern.counts)/dim(ambiguities[[k]])[2]
}
# combine the patterns
#pattern.counts.amb.all.sum<-Reduce(`+`, pattern.counts.amb.all)
pattern.counts<-pattern.counts+amb.pattern.counts.sum #pattern.counts.amb.all.sum
# Compute SVD Score
flat_12_34<-matrix(pattern.counts, nrow=16, byrow=T)
sqrt(sum(svd(flat_12_34/500, nu=0, nv=0)$d[5:16]^2))
flat_12_34
flat_12_34/500
# empty vector of all 256 patterns. Adjust in the future to any number of states
pattern.counts<-numeric(4^4)
pattern.counts[as.numeric(names(table(counts)))]<-table(counts)
names(ambiguities)
seq.data<-ReadCharacters("10state-nooutgcell.nex")
cells<-rownames(seq.data)
for(i in 1:dim(seq.data)[1])
{
seq.data[i,]<-as.numeric(c('A'='1', 'C'='2', 'G'='3', 'T'='4',
'M'='5', 'R'='6', 'W'='7', 'S'='8',
'Y'='9', 'K'='10')[seq.data[i,]])
}
# read look-up table for ambiguities M, R, W, S, Y, K
# this is a list() object that encodes patterns on 4-species, e.g., YCCM
# all letters are coded by numbers as above
# each pattern then has and associated matrix of equally distributed ambiguities
# that is a location for a pattern YCCC will have a matrix with columns
# CCCC and TCCC
amb.table<-readRDS("ambiguities_list_four_taxa.RData")
# create all combinations of 4 from all species
# this gives a matrix of 4 rows and all possible combinations in columns
combinations<-combn(length(cells), 4)
patterns<-permutations(4,4,c(1:4), repeats=T)
patterns.list<-do.call(paste, as.data.frame(patterns))
# empty vector of all 256 patterns. Adjust in the future to any number of states
pattern.counts<-numeric(4^4)
# subset 4 sequences
subset<-cbind(seq.data[combinations[,s],][1,],
seq.data[combinations[,s],][2,],
seq.data[combinations[,s],][3,],
seq.data[combinations[,s],][4,])
subset.patterns<-do.call(paste, as.data.frame(subset))
counts<-match(subset.patterns,patterns.list)
pattern.counts[as.numeric(names(table(counts)))]<-table(counts)
pattern.counts
# get positions where ambiguities occur and subset patterns
#amb.positions<-which(is.na(counts))
amb.patterns<-subset.patterns[which(is.na(counts))]
# Use the patterns to get a subset from a list() loaded previously
ambiguities<-amb.table[which(is.na(counts))]
names(ambiguities)
s
combinations[,s]
table(subset.patterns)
amb.patterns
which(is.na(counts))
# Use the patterns to get a subset from a list() loaded previously
ambiguities<-amb.table[amb.patterns]
names(ambiguities)
amb.pattern.counts.sum<-numeric(256)
for(k in 1:length(ambiguities))
{
amb.pattern.counts<-numeric(256)
amb.subset.patterns<-do.call(paste, as.data.frame(t(ambiguities[[k]])))
amb.counts<-match(amb.subset.patterns,patterns.list)
#amb.pattern.counts[as.numeric(names(table(amb.counts)))]<-table(amb.counts)/dim(ambiguities[[k]])[2]
amb.pattern.counts[amb.counts]<-1/dim(ambiguities[[k]])[2]
amb.pattern.counts.sum<-amb.pattern.counts.sum + amb.pattern.counts
#pattern.counts.amb.all[[k]]<-amb.pattern.counts)/dim(ambiguities[[k]])[2]
}
# combine the patterns
#pattern.counts.amb.all.sum<-Reduce(`+`, pattern.counts.amb.all)
pattern.counts<-pattern.counts+amb.pattern.counts.sum #pattern.counts.amb.all.sum
# Compute SVD Score
flat_12_34<-matrix(pattern.counts, nrow=16, byrow=T)
flat_12_34/500
sqrt(sum(svd(flat_12_34/500, nu=0, nv=0)$d[5:16]^2))
TreeDistance(tree.qfm, tree.svdq)
tree.qfm2<-read.tree("4_state_best_quartetes_test2.tre")
TreeDistance(true.tree, tree.qfm)
TreeDistance(true.tree, tree.qfm2)
TreeDistance(tree.qfm, tree.qfm2)
source("~/Documents/seq_to_SVDQ/load_nexus_return_best_quartet_v3.R")
source("~/Documents/seq_to_SVDQ/load_nexus_return_best_quartet_v3.R")
source("~/Documents/seq_to_SVDQ/load_nexus_return_best_quartet_v3.R")
source("~/Documents/seq_to_SVDQ/load_nexus_return_best_quartet_v3.R")
source("~/Documents/seq_to_SVDQ/load_nexus_return_best_quartet_v3.R")
source("~/Documents/seq_to_SVDQ/ambiguties_list.R")
length(pattern.counts.amb.all)
Distribute.Ambiguities<-function(vec=c(a11,a12,a21,a22,a31,a32,a41,a42))
{
x<-rbind(
c(rep(vec[1],8),rep(vec[2],8)),
rep(c(rep(vec[3],4),rep(vec[4],4)),2),
rep(c(rep(vec[5],2),rep(vec[6],2)),4),
rep(c(vec[7],vec[8]),8))
return(unique(x, MARGIN=2))
}
#----------------------------------------------
ambiguities.table<-rbind(c(1,2), c(1,3), c(1,4),
c(2,3), c(2,4), c(3,4))
names<-c(5,6,7,8,9,10)
patterns<-permutations(4,4,c(1:4), repeats=T)
patterns.list<-do.call(paste, as.data.frame(patterns))
all.patterns<-permutations(10,4,c(1:10), repeats=T)
all.patterns.list<-do.call(paste, as.data.frame(all.patterns))
all.counts<-match(all.patterns.list,patterns.list)
amb.positions<-which(is.na(all.counts))
amb.patterns<-all.patterns[amb.positions,]
amb.patterns.names<-all.patterns.list[amb.positions]
amb.list<-list()
for(i in 1:dim(amb.patterns)[1])
{
hold<-numeric(8)
for(j in 1:4)
{
ifelse(amb.patterns[i,j]<5,
hold[(2*j-1):(2*j)]<-rep(amb.patterns[i,j],2),
hold[(2*j-1):(2*j)]<-ambiguities.table[which(names==amb.patterns[i,j]),])
}
amb.list[[i]]<-Distribute.Ambiguities(hold)
names(amb.list)[[i]]<-amb.patterns.names[i]
}
amb.list[[1]]
names(amb.list[[1]])
names(amb.list)[1:10]
length(amb.list)
pattern.counts.amb.all<-list()
patterns.list
dim(amb.list[[1]])
dim(amb.list[[3]])
dim(amb.list[[10]])
dim(amb.list[[100]])
dim(amb.list[[130]])
amb.list[[130]]
amb.list[[1300]]
dim(amb.list[[1300]])
pattern.counts.amb.all<-list()
for(k in 1:length(amb.list))
{
amb.pattern.counts<-numeric(256)
amb.subset.patterns<-do.call(paste, as.data.frame(t(amb.list[[k]])))
amb.counts<-match(amb.subset.patterns,patterns.list)
#amb.pattern.counts[as.numeric(names(table(amb.counts)))]<-table(amb.counts)/dim(ambiguities[[k]])[2]
amb.pattern.counts[amb.counts]<-1/dim(amb.list[[k]])[2]
#amb.pattern.counts.sum<-amb.pattern.counts.sum + amb.pattern.counts
pattern.counts.amb.all[[k]]<-amb.pattern.counts
}
length(pattern.counts.amb.all)
pattern.counts.amb.all[[1]]
pattern.counts.amb.all[[1300]]
saveRDS(pattern.counts.amb.all,file="ambuguities_counts_four_taxa.RData")
amb.counts<-readRDS("ambuguities_counts_four_taxa.RData")
amb.counts["9999"]
amb.couns[[1]]
amb.counts[[1]]
names(amb.counts)[1:10]
names(pattern.counts.amb.all)[1:10]
names(amb.list)[[1]]
names(amb.list)[[2]]
names(amb.list)[[1300]]
pattern.counts.amb.all<-list()
for(k in 1:length(amb.list))
{
amb.pattern.counts<-numeric(256)
amb.subset.patterns<-do.call(paste, as.data.frame(t(amb.list[[k]])))
amb.counts<-match(amb.subset.patterns,patterns.list)
#amb.pattern.counts[as.numeric(names(table(amb.counts)))]<-table(amb.counts)/dim(ambiguities[[k]])[2]
amb.pattern.counts[amb.counts]<-1/dim(amb.list[[k]])[2]
#amb.pattern.counts.sum<-amb.pattern.counts.sum + amb.pattern.counts
pattern.counts.amb.all[[k]]<-amb.pattern.counts
names(pattern.counts.amb.all)[[k]]<-names(amb.list)[[k]]
}
names(pattern.counts.amb.all)[1:10]
saveRDS(pattern.counts.amb.all,file="ambuguities_counts_four_taxa.RData")
amb.counts<-readRDS("ambuguities_counts_four_taxa.RData")
amb.counts[[1]]
names(amb.counts)[1:10]
amb.counts["9 9 9 9"]
seq.data<-ReadCharacters("10state-nooutgcell.nex")
cells<-rownames(seq.data)
for(i in 1:dim(seq.data)[1])
{
seq.data[i,]<-as.numeric(c('A'='1', 'C'='2', 'G'='3', 'T'='4',
'M'='5', 'R'='6', 'W'='7', 'S'='8',
'Y'='9', 'K'='10')[seq.data[i,]])
}
# read list of all ambiguities as a bove but with counts
amb.counts<-readRDS("ambuguities_counts_four_taxa.RData")
# create all combinations of 4 from all species
# this gives a matrix of 4 rows and all possible combinations in columns
combinations<-combn(length(cells), 4)
patterns<-permutations(4,4,c(1:4), repeats=T)
patterns.list<-do.call(paste, as.data.frame(patterns))
# empty vector of all 256 patterns. Adjust in the future to any number of states
pattern.counts<-numeric(4^4)
s
# subset 4 sequences
subset<-cbind(seq.data[combinations[,s],][1,],
seq.data[combinations[,s],][2,],
seq.data[combinations[,s],][3,],
seq.data[combinations[,s],][4,])
subset.patterns<-do.call(paste, as.data.frame(subset))
counts<-match(subset.patterns,patterns.list)
pattern.counts[as.numeric(names(table(counts)))]<-table(counts)
# get positions where ambiguities occur and subset patterns
#amb.positions<-which(is.na(counts))
amb.patterns<-subset.patterns[which(is.na(counts))]
# Use the patterns to get a subset from a list() loaded previously
ambiguities<-amb.counts[amb.patterns]
# combine the patterns
pattern.counts.amb.all.sum<-Reduce(`+`, ambiguities)
pattern.counts<-pattern.counts+amb.pattern.counts.sum #pattern.counts.amb.all.sum
# Compute SVD Score
flat_12_34<-matrix(pattern.counts, nrow=16, byrow=T)
flat_12_34/500
sqrt(sum(svd(flat_12_34/500)$d[5:16]^2))
source("~/Documents/seq_to_SVDQ/load_nexus_return_best_quartet_v3.R")
rm(amb.counts)
source("~/Documents/seq_to_SVDQ/load_nexus_return_best_quartet_v3.R")
source("~/Documents/seq_to_SVDQ/load_nexus_return_best_quartet_v3.R")
system.time(Reduce(`+`, ambiguities))
amb.patterns
system.time(amb.counts[amb.patterns])
# read list of all ambiguities as a bove but with counts
amb.counts<-readRDS("ambuguities_counts_four_taxa.RData")
system.time(amb.counts[amb.patterns])
seq.data<-ReadCharacters("10state-nooutgcell.nex")
# read list of all ambiguities as a bove but with counts
amb.counts<-readRDS("ambuguities_counts_four_taxa.RData")
# create all combinations of 4 from all species
# this gives a matrix of 4 rows and all possible combinations in columns
combinations<-combn(length(cells), 4)
patterns<-permutations(4,4,c(1:4), repeats=T)
patterns.list<-do.call(paste, as.data.frame(patterns))
# empty vector of all 256 patterns. Adjust in the future to any number of states
pattern.counts<-numeric(4^4)
# subset 4 sequences
subset<-cbind(seq.data[combinations[,s],][1,],
seq.data[combinations[,s],][2,],
seq.data[combinations[,s],][3,],
seq.data[combinations[,s],][4,])
subset.patterns<-do.call(paste, as.data.frame(subset))
counts<-match(subset.patterns,patterns.list)
pattern.counts[as.numeric(names(table(counts)))]<-table(counts)
# get positions where ambiguities occur and subset patterns
#amb.positions<-which(is.na(counts))
amb.patterns<-subset.patterns[which(is.na(counts))]
# Use the patterns to get a subset from a list() loaded previously
ambiguities<-amb.counts[amb.patterns]
# combine the patterns
# pattern.counts.amb.all.sum<-Reduce(`+`, ambiguities)
pattern.counts<-pattern.counts+Reduce(`+`, ambiguities)# amb.pattern.counts.sum #pattern.counts.amb.all.sum
# Compute SVD Score
flat_12_34<-matrix(pattern.counts, nrow=16, byrow=T)
sqrt(sum(svd(flat_12_34/500)$d[5:16]^2))
source("~/Documents/seq_to_SVDQ/load_nexus_return_best_quartet_v3.R")
source("~/Documents/seq_to_SVDQ/load_nexus_return_best_quartet_v3.R")
source("~/Documents/seq_to_SVDQ/load_nexus_return_best_quartet_v3.R")
source("~/Documents/seq_to_SVDQ/load_nexus_return_best_quartet_v3.R")
source("~/Documents/seq_to_SVDQ/load_nexus_return_best_quartet_v3.R")
source("~/Documents/seq_to_SVDQ/load_nexus_return_best_quartet_v3.R")
source("~/Documents/seq_to_SVDQ/load_nexus_return_best_quartet_v3.R")
source("~/Documents/seq_to_SVDQ/load_nexus_return_best_quartet_v3.R")
source("~/Documents/seq_to_SVDQ/load_nexus_return_best_quartet_v3.R")
tree.qfm.23<-read.tree("4_state_best_quartetes_test_2023.tre")
TreeDistance(tree.qfm.23, true.tree)
TreeDistance(tree.16, true.tree)
TreeDistance(tree.qfm, true.tree)
TreeDistance(tree.qfm2, true.tree)
TreeDistance(tree.svdq, true.tree)
source("~/Documents/seq_to_SVDQ/DNA_4_state_with_ambiguities_load_nexus_return_best_quartet.R")
25000/4000
25000/3
shiny::runApp('~/Documents/Constru/constru_app')
